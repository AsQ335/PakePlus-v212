# 系统代理问题诊断

## 问题描述

- **TUN 模式**：✅ 可以访问 lmarena.ai
- **系统代理模式**：❌ 无法通过 Cloudflare 验证

## 诊断步骤

### 步骤 1：对比网络请求

#### 在 TUN 模式下

1. 启用 TUN 模式
2. 打开 PakePlus
3. 打开开发者工具 → Network 标签
4. 访问 `https://lmarena.ai`
5. 查看第一个请求的详细信息：
   - Request Headers
   - Response Headers
   - Timing

**记录以下信息：**
```
Request URL: 
Request Method: 
Status Code: 
Remote Address: 

Request Headers:
- User-Agent: 
- Accept: 
- Accept-Encoding: 
- Accept-Language: 
- Connection: 
- Host: 
- Referer: 
- Sec-Fetch-*: 
- 其他特殊 headers: 

Response Headers:
- Server: 
- CF-Ray: 
- CF-Cache-Status: 
- 其他 CF-* headers: 
```

#### 在系统代理模式下

1. 关闭 TUN 模式
2. 启用系统代理
3. 重复上述步骤
4. 记录相同的信息

#### 对比差异

找出两种模式下的差异：
- [ ] Request Headers 是否相同？
- [ ] 是否有额外的 headers？
- [ ] User-Agent 是否相同？
- [ ] 是否有 Proxy-* 相关的 headers？

### 步骤 2：检查 DNS 解析

#### TUN 模式

```bash
# 在应用中打开控制台，运行：
fetch('https://lmarena.ai')
  .then(r => console.log('TUN 模式 - 成功'))
  .catch(e => console.log('TUN 模式 - 失败:', e));
```

#### 系统代理模式

```bash
# 同样的代码
fetch('https://lmarena.ai')
  .then(r => console.log('系统代理 - 成功'))
  .catch(e => console.log('系统代理 - 失败:', e));
```

### 步骤 3：检查 WebSocket 连接（如果有）

lmarena.ai 可能使用 WebSocket，检查：

```javascript
// 在控制台运行
console.log('WebSocket 支持:', 'WebSocket' in window);

// 查看 Network 标签中是否有 WS 连接
// 对比 TUN 和系统代理模式下的差异
```

### 步骤 4：检查 Cloudflare Challenge

#### 查看是否触发了 Challenge

在系统代理模式下，查看：
1. 是否出现 "Checking your browser" 页面？
2. 是否一直卡在验证中？
3. 是否直接显示 "Access Denied"？

**记录 Challenge 类型：**
- [ ] JavaScript Challenge (5 秒等待)
- [ ] Managed Challenge (需要点击)
- [ ] CAPTCHA
- [ ] 直接拒绝

### 步骤 5：检查 Cookies

#### TUN 模式

```javascript
// 在控制台运行
console.log('Cookies:', document.cookie);
```

#### 系统代理模式

```javascript
// 同样的代码
console.log('Cookies:', document.cookie);
```

**对比：**
- [ ] 是否有 `cf_clearance` cookie？
- [ ] 是否有其他 Cloudflare cookies？

### 步骤 6：检查 JavaScript 执行

在系统代理模式下，检查是否有 JavaScript 错误：

```javascript
// 在控制台运行
window.addEventListener('error', (e) => {
  console.error('JavaScript 错误:', e.message, e.filename, e.lineno);
});

window.addEventListener('unhandledrejection', (e) => {
  console.error('Promise 错误:', e.reason);
});
```

### 步骤 7：使用 Wireshark 抓包（高级）

如果上述方法都找不到问题，使用 Wireshark：

1. 启动 Wireshark
2. 过滤：`tcp.port == 7890 or tcp.port == 7891`
3. 对比 TUN 和系统代理模式的流量差异

**查看：**
- TLS Client Hello 的差异
- HTTP/2 帧的差异
- 是否有额外的连接

## 可能的原因

### 原因 1：Proxy-Connection Header

系统代理可能添加了 `Proxy-Connection` header：

```javascript
// 在 custom.js 中添加
(function() {
  const originalFetch = window.fetch;
  window.fetch = function(url, options = {}) {
    // 移除可能的 Proxy-* headers
    if (options.headers) {
      delete options.headers['Proxy-Connection'];
      delete options.headers['Proxy-Authorization'];
    }
    return originalFetch(url, options);
  };
})();
```

### 原因 2：DNS 泄露

系统代理模式下，DNS 可能在本地解析：

```javascript
// 检查 DNS
fetch('https://1.1.1.1/cdn-cgi/trace')
  .then(r => r.text())
  .then(t => console.log('Cloudflare Trace:', t));
```

**对比输出：**
- `ip=` 应该是代理服务器的 IP
- 如果是本地 IP，说明有泄露

### 原因 3：HTTP/2 vs HTTP/1.1

系统代理可能强制使用 HTTP/1.1：

在 Network 标签中查看：
- Protocol 列是否显示 `h2` (HTTP/2) 或 `http/1.1`

### 原因 4：TLS 版本

检查 TLS 版本：

```javascript
// 在控制台运行
fetch('https://www.howsmyssl.com/a/check')
  .then(r => r.json())
  .then(data => {
    console.log('TLS Version:', data.tls_version);
    console.log('Cipher Suite:', data.given_cipher_suites);
  });
```

### 原因 5：WebView 特定的 Headers

WebView 可能添加了特殊的 headers：

在 Network 标签中查找：
- `X-Requested-With`
- `X-WebView-*`
- 其他非标准 headers

## 解决方案模板

根据诊断结果，在 `custom.js` 中添加对应的修复：

```javascript
(function() {
  'use strict';
  
  // 根据诊断结果，添加对应的修复代码
  
  // 示例 1：移除特殊 headers
  const originalFetch = window.fetch;
  window.fetch = function(url, options = {}) {
    if (options.headers) {
      // 移除可疑的 headers
      delete options.headers['X-Requested-With'];
    }
    return originalFetch(url, options);
  };
  
  // 示例 2：修改 XMLHttpRequest
  const OriginalXHR = window.XMLHttpRequest;
  window.XMLHttpRequest = function() {
    const xhr = new OriginalXHR();
    const originalSetRequestHeader = xhr.setRequestHeader;
    
    xhr.setRequestHeader = function(name, value) {
      // 过滤特定的 headers
      if (name.toLowerCase().startsWith('proxy-')) {
        return;
      }
      return originalSetRequestHeader.call(this, name, value);
    };
    
    return xhr;
  };
  
  console.log('[Proxy Fix] 已应用修复');
})();
```

## 下一步

1. **完成诊断步骤 1-7**
2. **记录所有差异**
3. **根据差异选择对应的解决方案**
4. **测试验证**

请先完成诊断，然后告诉我具体的差异，我们再针对性地解决！

---

**重要：** 不要再推测了，让我们用实际数据来找出问题！
