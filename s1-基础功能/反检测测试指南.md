# Cloudflare 反检测测试指南

## 📋 测试前准备

### 1. 确认文件已更新

```bash
# 检查文件是否已更新
type PakePlus-v212\src-tauri\data\custom.js | findstr "AntiDetect"
```

应该看到 `[AntiDetect]` 相关的日志输出。

### 2. 启动开发模式

```bash
cd PakePlus-v212
pnpm run tauri:dev
```

## 🧪 测试步骤

### 测试 1：检查反检测模块是否启动

1. 打开应用后，右键点击页面
2. 选择"检查"打开开发者工具
3. 查看控制台，应该看到：

```
=== [AntiDetect] Cloudflare 反检测模块启动 ===
[AntiDetect] ℹ️ 开始配置 WebRTC 保护...
[AntiDetect] ✅ RTCPeerConnection 保护已启用
[AntiDetect] ✅ getUserMedia 已禁用
[AntiDetect] ✅ 浏览器指纹修改完成
[AntiDetect] ✅ Canvas 指纹保护已启用
[AntiDetect] ✅ WebGL 指纹保护已启用
[AntiDetect] ✅ 时区修改完成（UTC+8）
=== [AntiDetect] Cloudflare 反检测模块启动完成 ===
```

### 测试 2：验证 WebRTC IP 泄露保护

在控制台执行以下代码：

```javascript
// 测试 WebRTC IP 泄露
async function testWebRTC() {
  console.log('=== 开始测试 WebRTC ===');
  
  try {
    const pc = new RTCPeerConnection({
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    });
    
    pc.createDataChannel('test');
    
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    
    let candidateCount = 0;
    
    pc.onicecandidate = (event) => {
      if (event.candidate) {
        candidateCount++;
        console.log(`Candidate ${candidateCount}:`, event.candidate.candidate);
        
        // 检查是否包含本地 IP
        const c = event.candidate.candidate;
        if (c.includes('192.168.') || c.includes('10.') || c.includes('172.')) {
          console.error('❌ 检测到本地 IP 泄露！');
        } else {
          console.log('✅ 未检测到本地 IP');
        }
      } else {
        console.log(`总共收集到 ${candidateCount} 个 candidates`);
        if (candidateCount === 0) {
          console.log('✅ WebRTC 保护成功：没有收集到任何 candidate');
        }
      }
    };
    
    // 等待 5 秒
    setTimeout(() => {
      pc.close();
      console.log('=== WebRTC 测试完成 ===');
    }, 5000);
    
  } catch (error) {
    console.error('WebRTC 测试出错:', error);
  }
}

testWebRTC();
```

**预期结果**：
- ✅ 应该看到 `[AntiDetect] 拦截 RTCPeerConnection 创建`
- ✅ 应该看到 `WebRTC 保护成功：没有收集到任何 candidate`
- ❌ 不应该看到任何包含 `192.168.` 或 `10.` 的 IP 地址

### 测试 3：验证浏览器指纹修改

在控制台执行：

```javascript
// 测试浏览器指纹
console.log('=== 浏览器指纹测试 ===');
console.log('User-Agent:', navigator.userAgent);
console.log('Platform:', navigator.platform);
console.log('Vendor:', navigator.vendor);
console.log('Webdriver:', navigator.webdriver);
console.log('Languages:', navigator.languages);
console.log('Hardware Concurrency:', navigator.hardwareConcurrency);
console.log('Device Memory:', navigator.deviceMemory);
console.log('Max Touch Points:', navigator.maxTouchPoints);
console.log('Plugins:', navigator.plugins.length);
console.log('Chrome 对象存在:', !!window.chrome);
console.log('======================');
```

**预期结果**：
```
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36
Platform: Win32
Vendor: Google Inc.
Webdriver: undefined
Languages: ["zh-CN", "zh", "en-US", "en"]
Hardware Concurrency: 8
Device Memory: 8
Max Touch Points: 0
Plugins: 3
Chrome 对象存在: true
```

### 测试 4：验证 Canvas 指纹保护

```javascript
// 测试 Canvas 指纹
function testCanvas() {
  console.log('=== Canvas 指纹测试 ===');
  
  const canvas = document.createElement('canvas');
  canvas.width = 200;
  canvas.height = 50;
  const ctx = canvas.getContext('2d');
  
  ctx.textBaseline = 'top';
  ctx.font = '14px Arial';
  ctx.fillStyle = '#f60';
  ctx.fillRect(125, 1, 62, 20);
  ctx.fillStyle = '#069';
  ctx.fillText('Canvas Fingerprint Test', 2, 15);
  
  const dataURL1 = canvas.toDataURL();
  const dataURL2 = canvas.toDataURL();
  
  console.log('第一次 toDataURL 长度:', dataURL1.length);
  console.log('第二次 toDataURL 长度:', dataURL2.length);
  console.log('两次结果相同:', dataURL1 === dataURL2);
  console.log('======================');
}

testCanvas();
```

**预期结果**：
- 两次 `toDataURL` 的结果应该相同（同一页面内）
- 长度应该正常（不为 0）

### 测试 5：验证 WebGL 指纹保护

```javascript
// 测试 WebGL 指纹
function testWebGL() {
  console.log('=== WebGL 指纹测试 ===');
  
  const canvas = document.createElement('canvas');
  const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
  
  if (gl) {
    const vendor = gl.getParameter(gl.VENDOR);
    const renderer = gl.getParameter(gl.RENDERER);
    const unmaskedVendor = gl.getParameter(gl.getExtension('WEBGL_debug_renderer_info').UNMASKED_VENDOR_WEBGL);
    const unmaskedRenderer = gl.getParameter(gl.getExtension('WEBGL_debug_renderer_info').UNMASKED_RENDERER_WEBGL);
    
    console.log('Vendor:', vendor);
    console.log('Renderer:', renderer);
    console.log('Unmasked Vendor:', unmaskedVendor);
    console.log('Unmasked Renderer:', unmaskedRenderer);
  } else {
    console.log('WebGL 不可用');
  }
  
  console.log('======================');
}

testWebGL();
```

**预期结果**：
```
Unmasked Vendor: Intel Inc.
Unmasked Renderer: Intel(R) UHD Graphics 630
```

### 测试 6：验证时区修改

```javascript
// 测试时区
console.log('=== 时区测试 ===');
console.log('Timezone Offset:', new Date().getTimezoneOffset());
console.log('预期值: -480 (UTC+8)');
console.log('Timezone:', Intl.DateTimeFormat().resolvedOptions().timeZone);
console.log('预期值: Asia/Shanghai');
console.log('======================');
```

**预期结果**：
```
Timezone Offset: -480
Timezone: Asia/Shanghai
```

### 测试 7：验证媒体设备禁用

```javascript
// 测试媒体设备
async function testMediaDevices() {
  console.log('=== 媒体设备测试 ===');
  
  // 测试 getUserMedia
  try {
    await navigator.mediaDevices.getUserMedia({ audio: true });
    console.log('❌ getUserMedia 未被禁用');
  } catch (error) {
    console.log('✅ getUserMedia 已禁用:', error.message);
  }
  
  // 测试 enumerateDevices
  try {
    const devices = await navigator.mediaDevices.enumerateDevices();
    console.log('设备数量:', devices.length);
    if (devices.length === 0) {
      console.log('✅ enumerateDevices 已禁用');
    } else {
      console.log('❌ enumerateDevices 未被禁用');
    }
  } catch (error) {
    console.log('enumerateDevices 出错:', error.message);
  }
  
  console.log('======================');
}

testMediaDevices();
```

**预期结果**：
```
✅ getUserMedia 已禁用: Permission denied
✅ enumerateDevices 已禁用
```

## 🌐 实际测试：访问 lmarena.ai

### 步骤 1：配置代理

确保 Clash Verge 使用**系统代理模式**（不是 TUN 模式）：

1. 打开 Clash Verge
2. 设置 → 系统代理 → **开启**
3. 设置 → TUN 模式 → **关闭**

### 步骤 2：访问测试

在应用中访问：`https://lmarena.ai`

### 步骤 3：观察结果

**成功标志**：
- ✅ 页面正常加载
- ✅ 没有出现 Cloudflare 验证页面
- ✅ 可以正常使用网站功能

**失败标志**：
- ❌ 出现 Cloudflare "Checking your browser" 页面
- ❌ 页面一直在验证中
- ❌ 出现 "Access Denied" 错误

### 步骤 4：查看日志

在控制台查看是否有相关日志：

```
[AntiDetect] 拦截 RTCPeerConnection 创建
[AntiDetect] 过滤本地 IP candidate: ...
```

## 🔍 问题排查

### 问题 1：仍然无法通过验证

**可能原因**：
1. DNS 泄露
2. 代理配置问题
3. IP 信誉问题

**解决方法**：

#### 方法 1：检查 DNS 泄露

访问：https://www.dnsleaktest.com/

如果显示的 DNS 服务器是本地的，说明有 DNS 泄露。

**解决**：在 Clash Verge 中启用 DNS 劫持：
```yaml
dns:
  enable: true
  enhanced-mode: fake-ip
  nameserver:
    - 8.8.8.8
    - 1.1.1.1
```

#### 方法 2：使用 fake-ip 模式

在 Clash Verge 配置中：
```yaml
dns:
  enable: true
  enhanced-mode: fake-ip
  fake-ip-range: 198.18.0.1/16
```

#### 方法 3：检查代理是否生效

在控制台执行：
```javascript
fetch('https://api.ipify.org?format=json')
  .then(r => r.json())
  .then(data => console.log('当前 IP:', data.ip));
```

应该显示代理服务器的 IP，而不是本地 IP。

### 问题 2：反检测模块未启动

**检查**：
1. 确认 `custom.js` 文件已更新
2. 重新构建应用：`pnpm run tauri:build`
3. 清除缓存后重启

### 问题 3：WebRTC 仍然泄露 IP

**增强保护**：

在 `custom.js` 中找到 WebRTC 保护部分，确认配置：
```javascript
configuration.iceServers = [];  // 必须为空数组
configuration.iceTransportPolicy = 'relay';  // 必须为 relay
```

## 📊 测试报告模板

完成测试后，记录结果：

```
=== Cloudflare 反检测测试报告 ===

测试时间：2025-11-17
代理模式：系统代理 / TUN 模式
代理服务器：[你的代理服务器]

【反检测模块】
✅/❌ 模块启动成功
✅/❌ WebRTC 保护生效
✅/❌ 浏览器指纹修改成功
✅/❌ Canvas 保护生效
✅/❌ WebGL 保护生效
✅/❌ 时区修改成功
✅/❌ 媒体设备禁用成功

【实际访问测试】
✅/❌ lmarena.ai 访问成功
✅/❌ 通过 Cloudflare 验证
✅/❌ 功能正常使用

【问题记录】
[记录遇到的问题]

【解决方案】
[记录解决方法]

===================================
```

## 🎯 最佳实践

1. **开发阶段**：启用详细日志（`verbose: true`）
2. **生产环境**：关闭详细日志（`verbose: false`）
3. **定期测试**：每次更新后都要测试
4. **监控日志**：关注用户反馈的验证问题

## 📞 获取帮助

如果测试失败，请提供：
1. 完整的控制台日志
2. 测试报告
3. 代理配置信息
4. 网络环境信息

---

**祝测试顺利！** 🚀
